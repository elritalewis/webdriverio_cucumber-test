"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const logger_1 = __importDefault(require("@wdio/logger"));
const saucelabs_1 = __importDefault(require("saucelabs"));
const utils_js_1 = require("./utils.js");
const SC_RELAY_DEPCRECATION_WARNING = [
    'The "scRelay" option is depcrecated and will be removed',
    'with the upcoming versions of @wdio/sauce-service. Please',
    'remove the option as tests should work identically without it.'
].join(' ');
const log = logger_1.default('@wdio/sauce-service');
class SauceLauncher {
    constructor(options, capabilities, config) {
        this.options = options;
        this.api = new saucelabs_1.default(config);
    }
    async onPrepare(config, capabilities) {
        if (!this.options.sauceConnect) {
            return;
        }
        const sauceConnectOpts = this.options.sauceConnectOpts || {};
        const sauceConnectTunnelIdentifier = (sauceConnectOpts.tunnelIdentifier ||
            `SC-tunnel-${Math.random().toString().slice(2)}`);
        this.sauceConnectOpts = {
            noAutodetect: true,
            tunnelIdentifier: sauceConnectTunnelIdentifier,
            ...sauceConnectOpts
        };
        let endpointConfigurations = {};
        if (this.options.scRelay) {
            log.warn(SC_RELAY_DEPCRECATION_WARNING);
            const scRelayPort = this.sauceConnectOpts.port || 4445;
            this.sauceConnectOpts.sePort = scRelayPort;
            endpointConfigurations = {
                protocol: 'http',
                hostname: 'localhost',
                port: scRelayPort
            };
        }
        const prepareCapability = utils_js_1.makeCapabilityFactory(sauceConnectTunnelIdentifier, endpointConfigurations);
        if (Array.isArray(capabilities)) {
            for (const capability of capabilities) {
                prepareCapability(capability);
            }
        }
        else {
            for (const browserName of Object.keys(capabilities)) {
                prepareCapability(capabilities[browserName].capabilities);
            }
        }
        const obs = new perf_hooks_1.PerformanceObserver((list) => {
            const entry = list.getEntries()[0];
            log.info(`Sauce Connect successfully started after ${entry.duration}ms`);
        });
        obs.observe({ entryTypes: ['measure'], buffered: false });
        perf_hooks_1.performance.mark('sauceConnectStart');
        this.sauceConnectProcess = await this.api.startSauceConnect(this.sauceConnectOpts);
        perf_hooks_1.performance.mark('sauceConnectEnd');
        perf_hooks_1.performance.measure('bootTime', 'sauceConnectStart', 'sauceConnectEnd');
    }
    onComplete() {
        if (!this.sauceConnectProcess) {
            return;
        }
        return this.sauceConnectProcess.close();
    }
}
exports.default = SauceLauncher;
