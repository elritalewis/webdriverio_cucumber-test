"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const saucelabs_1 = __importDefault(require("saucelabs"));
const logger_1 = __importDefault(require("@wdio/logger"));
const utils_1 = require("./utils");
const jobDataProperties = ['name', 'tags', 'public', 'build', 'custom-data'];
const log = logger_1.default('@wdio/sauce-service');
class SauceService {
    constructor(options) {
        this.testCnt = 0;
        this.failures = 0;
        this.options = options || {};
    }
    beforeSession(config, capabilities) {
        this.config = config;
        this.capabilities = capabilities;
        this.api = new saucelabs_1.default(this.config);
        this.isRDC = 'testobject_api_key' in this.capabilities;
        this.isServiceEnabled = true;
        if (!this.isRDC && !config.user) {
            this.isServiceEnabled = false;
            config.user = 'unknown_user';
        }
        if (!this.isRDC && !config.key) {
            this.isServiceEnabled = false;
            config.key = 'unknown_key';
        }
    }
    before() {
        const capabilities = global.browser.capabilities || {};
        this.isUP = utils_1.isUnifiedPlatform(capabilities);
    }
    beforeSuite(suite) {
        this.suiteTitle = suite.title;
        if (this.options.setJobNameInBeforeSuite && !this.isUP) {
            global.browser.execute('sauce:job-name=' + this.suiteTitle);
        }
    }
    beforeTest(test) {
        if (!this.isServiceEnabled || this.isRDC || this.isUP) {
            return;
        }
        if (this.suiteTitle === 'Jasmine__TopLevel__Suite') {
            this.suiteTitle = test.fullName.slice(0, test.fullName.indexOf(test.description) - 1);
        }
        const fullTitle = (test.fullName ||
            `${test.parent} - ${test.title}`);
        global.browser.execute('sauce:context=' + fullTitle);
    }
    afterSuite(suite) {
        if (Object.prototype.hasOwnProperty.call(suite, 'error')) {
            ++this.failures;
        }
    }
    afterTest(test, context, results) {
        if (test._retriedTest && results.passed) {
            --this.failures;
            return;
        }
        if (test._retriedTest && !results.passed && test._currentRetry < test._retries) {
            return;
        }
        if (!results.passed) {
            ++this.failures;
        }
    }
    beforeFeature(uri, feature) {
        if (!this.isServiceEnabled || this.isRDC || this.isUP) {
            return;
        }
        this.suiteTitle = feature.document.feature.name;
        global.browser.execute('sauce:context=Feature: ' + this.suiteTitle);
    }
    beforeScenario(uri, feature, scenario) {
        if (!this.isServiceEnabled || this.isRDC || this.isUP) {
            return;
        }
        const scenarioName = scenario.name;
        global.browser.execute('sauce:context=Scenario: ' + scenarioName);
    }
    afterScenario(uri, feature, pickle, result) {
        if (result.status === 'failed') {
            ++this.failures;
        }
    }
    after(result) {
        if (!this.isServiceEnabled && !this.isRDC) {
            return;
        }
        let failures = this.failures;
        if (global.browser.config.mochaOpts && global.browser.config.mochaOpts.bail && Boolean(result)) {
            failures = 1;
        }
        const status = 'status: ' + (failures > 0 ? 'failing' : 'passing');
        if (!global.browser.isMultiremote) {
            log.info(`Update job with sessionId ${global.browser.sessionId}, ${status}`);
            return this.isUP ? this.updateUP(failures) : this.updateJob(global.browser.sessionId, failures);
        }
        return Promise.all(Object.keys(this.capabilities).map((browserName) => {
            log.info(`Update multiremote job for browser "${browserName}" and sessionId ${global.browser[browserName].sessionId}, ${status}`);
            return this.isUP ? this.updateUP(failures) : this.updateJob(global.browser[browserName].sessionId, failures, false, browserName);
        }));
    }
    onReload(oldSessionId, newSessionId) {
        if (!this.isServiceEnabled && !this.isRDC) {
            return;
        }
        const status = 'status: ' + (this.failures > 0 ? 'failing' : 'passing');
        if (!global.browser.isMultiremote) {
            log.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
            return this.updateJob(oldSessionId, this.failures, true);
        }
        const browserName = global.browser.instances.filter((browserName) => global.browser[browserName].sessionId === newSessionId)[0];
        log.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
        return this.updateJob(oldSessionId, this.failures, true, browserName);
    }
    async updateJob(sessionId, failures, calledOnReload = false, browserName) {
        if (this.isRDC) {
            await this.api.updateTest(sessionId, { passed: failures === 0 });
            this.failures = 0;
            return;
        }
        const body = this.getBody(failures, calledOnReload, browserName);
        await this.api.updateJob(this.config.user, sessionId, body);
        this.failures = 0;
    }
    getBody(failures, calledOnReload = false, browserName) {
        let body = {};
        body.name = this.suiteTitle;
        if (browserName) {
            body.name = `${browserName}: ${body.name}`;
        }
        if (calledOnReload || this.testCnt) {
            let testCnt = ++this.testCnt;
            if (global.browser.isMultiremote) {
                testCnt = Math.ceil(testCnt / global.browser.instances.length);
            }
            body.name += ` (${testCnt})`;
        }
        let caps = this.capabilities['sauce:options'] || this.capabilities;
        for (let prop of jobDataProperties) {
            if (!caps[prop]) {
                continue;
            }
            body[prop] = caps[prop];
        }
        body.passed = failures === 0;
        return body;
    }
    updateUP(failures) {
        return global.browser.execute(`sauce:job-result=${failures === 0}`);
    }
}
exports.default = SauceService;
